\documentclass[a4paper]{article}
%\usepackage{fullpage}
\usepackage[bottom=1in, left=1in, top=1in, right=2in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\pagestyle{myheadings}
\markright{}

\begin{document}
\title{6.945 Final Project\\
Tscheme: Using type inference to automatically complain about the programmer's code}
\date{\today}
\author{Aaron Graham-Horowitz, Ben Zinberg, Jan Polášek}
\maketitle

\newpage

\section{Introduction}

Tscheme is a static code analyser over a subset of MIT Scheme
that aims to reduce the number of bugs in user's code.
It uses static type analysis to derive supersets of values that can be taken on by
(sub)expressions.
If an empty set is derived, a type error is bound to happen and the error is reported.
If the derived set of values is non-empty, the user is allowed to query the sets of
values expressions can take on to get more information about the code they have written.

There are two common ways of doing static analysis.
One approach is static typing, which imposes type rules which are
over-approximations of what can happen in correct programs.
A good static typing scheme will provide some sort of type safety -
guarantees that will be enforced and that the programmer can rely on.
It is for example possible to statically determine that an integer ``plus''
operator will never be called with a string passed as an argument.
The disadvantage of any reasonable type system over a sufficiently powerful language
is that there will always be valid programs that do not violate the notion of
type safety guaranteed by the type system that nevertheless will not type check.
In other words, the type checker will never produce false-positives,
but can produce false-negatives.
As we wanted to have a static analyser that works on an existing Scheme
language (or a subset of), we decided to go in the other direction,
which is a code analyser.
Unlike a type checker, a code analyser will never produce false-negatives,
but can produce false-positive results.

\section{Assumptions}

Tscheme works on a functional subset of MIT Scheme.  Mutation greatly limits 
our ability to make inferences about types, as any variable that might be 
accessible outside the current scope could potentially be changed to any type 
at almost any time.  Rather than work around this complication we require that
submitted code be free of side-effects.  We make a few other restrictions on 
the code.  We do not allow for procedures with variable number of arguments;
this makes it easier to reason about the types of functions.  We do not, by 
default, support all Scheme primitive procedures, however each scheme 
primitive that we handle is explicitly given a type in our code, and more can 
easily be added as needed.  In a production version of Tscheme we would 
include all MIT Scheme primitives, but for this early version we include only 
some of most commonly used primitives for testing purposes.

Our implementation of type analysis is strict in the requirement of not producing 
false negatives.  To maintain this strictness we do not collect constraints 
from within the branches of a conditional (we do get constraints from the 
predicate, however).  Because we cannot determine which branches will be 
accessible, we assume the return value of an {\tt if} or {\tt cond}
statement is {\tt *top*}, the set of all possible types.

%Overview of the subset of scheme we handle, what things do not work with our
%analysis (ifs) and why

\section{Workflow}

%The general workflow, i.e. generating constraints, applying them to a mapping table
Our program is split into two independent parts.
First, we have a procedure that takes in code and generates ``type'' constraints.
These restrict the values that can be taken on by subexpressions of the
code that is being analysed.
We generate type variables for both variables and expressions
and use them to create the right restrictions by using constraints.

Next, we have a procedure that takes a list of constraints and uses them to
refine the sets of values that a type variable representing either a subexpression
or a code variable can take on.
Moreover, it makes sure that no type variable has no value to take on,
as if that is the case, the program is guaranteed to fail.

\section{Types and Constraints}
\label{sec:types-and-constraints}

A type in Tscheme represents a universe of possible values a variable can take 
on.  Each type variable has an associated Tscheme type, which is represented 
as a record-type with an attribute for each of the Scheme primitive types 
(boolean number symbol char string pair list procedure) holding the set of 
possible values of that type the variable could take on.  This set can be
{\tt *all*}, meaning all values of the type, {\tt *none*}, meaning the 
variable cannot have the type, or a {\tt finite-set} containing a list of unique
values of the type that the variable can take on.  This fine-grained level of 
detail allows us to precisely type functions like {\tt assq}, which can return 
a list or the value {\tt #f} but not the other boolean value, {\tt #t}.
The type {\tt *top*} has the value {\tt *all*} for every field.  

Type variables that can be procedures are handled slightly differently.  The 
procedure field can have the values {\tt *all*} or {\tt *none*}, or it can 
contain a list of type variables (not types), one for its return value and one 
for each of its fixed number of arguments.  Using type variables for the 
arguments and return value allows us to concisely represent the potentially 
recursive nature of procedure types. We use ``extended type variables'', 
described below, to reference the type variables contained in a procedure type.  

Constraints are also encoded using record types.  A constraint has a left 
side, a right side, and a relation between the left and right side.  Not all 
relations are symmetric, so the left and right sides have different 
interpretations.  The left side is what we call an ``extended type variable'', 
which can be a type variable or a reference to the return value or a numbered 
argument of an extended type variable.  Extended type variables allow us to 
easily make statements about properties of procedures.  The right side can be 
an extended type variable, or it can be a full Tscheme type.

A constraint represents one of three relations between types (or type 
variables). The simplest relation is ``equals'', which means the left side and 
the right side must have exactly the same type.  This is a symmetric relation 
and allows us to reduce our number of type variables through substitution when 
the right side is an extended type variable.
A similar relation is ``requires'', which tells us the left side must be a 
subset of the right side.  This is not symmetric, and does not add information 
about the right side, only the left.  Lastly the ``permits'' relation tells us 
that the variable on the left side is capable of taking on at least one value 
within the universe of types represented on the right side.  In other words, 
the intersection of the left and right sides must be nonempty.  ``Permits'' 
constraints are not useful for refining types, but can tell us when a type 
variable has no valid types and report a type error.  

The constraint record type also contains
metadata about the code that generated the constraint, which helps us give 
useful error reporting when a constraint is violated.  As we refine type 
variables we track the constraints that were used to make inferences about the 
type, so that when a user queries a code variable we can give them information 
about how the type associated with that variable was determined.

\section{Constraint generation}

%TODO Ben

\section{Refining types by using constraints}

%TODO Jan
This section discusses how we process the generated constraints, namely how do 
we get as much information as possible about the types of our type variables 
and how do we enforce that every type variable has at least one value it can 
take on along with enforcing that our ``permits'' constraints hold.  We will 
discuss the high-level implementation, omitting some implementation details 
and technicalities.

\subsection{Interface specification}
The procedure gets a list of constraints as an input.
It maintains a map from type variables to types.
Initially, all type variables are mapped to \texttt{*top*},
meaning that they can take on any value.
By processing the constraints, we refine the values the type variables can take on,
while keeping track of what constraints have restricted the possible values of each
type variable.
This information is then used for error reporting and dependency tracking and could be
further used by the user.

\subsection{Processing a constraint}

As discussed in section \ref{sec:types-and-constraints},
each constraint contains the left part, which is either a type variable
or it references a return value/argument of a procedure that can be taken on by the
type variable passed.
In the latter case, we have to recursively walk the type variable
mapping to obtain a type variable, if possible.
Note that this can fail if the referenced type variable cannot be a procedure
or can only be a procedure that doesn't have enough arguments, in which
case a type error is reported.
It can also fail because the type variable can be a procedure
but we do not have any more information about it at the moment, i.e. it is 
\texttt{*any*}.
In that case, we do not have any way of extracting information from this constraint
at the given point of computation, therefore it is skipped.
The right part of a constraint can also take on a type variable or a procedure reference.
If that is the case, we proceed in the same way.\\

Now we have reduced the problem to the case where we have two type variables,
or a type variable and a type.
We obtain the current type for type variables from the mapping,
and have two types, corresponding to the left and right part of the constraint.
By the semantics of the three constraints, we perform the following:
\begin{itemize}
\item
In the case of equals, we compute the intersection of the two
types.
We change the mapping of both type variables (or one if only one is present)
to this new type.
\item
In the case of requires, we compute the intersection of the two types
and update the mapping from the left type variable to map to this new type.
\item
In the case of a permits, we compute the intersection of the two types and verify
that it is not empty.
State of the map does not change in this case, as permits only requires that the
intersection of the two types is non-empty, i.e. that there is at least one common value.
\end{itemize}

\subsection{Processing order}

The ordering in which constraints are processed can have an effect on the result.
For example, if a permits comes before any requires and equals constraints,
it will always be true, however if it was run last, it might have found
an empty intersection of types.\\

If all constraints are run repeatedly until the mapping from type variables
to types converges or an empty type is derived, the order in which constraints are
processed does not matter anymore.
This also ensures that all information that can be gained from the constraints
is obtained and reflected in the refined types, therefore our code repeatedly
enforces all constraints until convergence is reached.\\

Our algorithm is guaranteed to terminate, as constraints can only contain finite sets
of specific values or infinite sets of classes of types, such as numbers or strings,
and the way constraints are generated, there won't be any recursive references between type
variables.
As we only have intersection, it is obvious that there is only a finite number of steps
that can be made before an empty type is derived.

\subsection{Computing intersection}

Computing an intersection of two types $tA$ and $tB$ is trivial for the most part.
The only tricky case occurs when we are intersecting two types that could take on a procedure
value, where both of them have a specified list of type variables that represent the
procedure's arguments and return types.
If these two types are not pairwise equal, we might need to enforce the given constraint on the
respective pairs of type variables.
However, we do this if and only if the intersection of types of $tA$ and $tB$ is otherwise empty.\\

It is trivial to see why this is necessary if the intersection of the types is otherwise empty,
as we do need to know whether the types all give non-empty intersections or not.
To see why we cannot do it in any case, consider for example a requires constraint.
Say that $tA$ can be either a number or a thunk that returns a string,
and $tB$ can be either a number or a thunk that returns a number.
Clearly, the intersection of the two types is a number.
However, if we proceeded with enforcing the constraint on the procedures,
we would derive a contradiction, although it is possible that the set of constraints
we were given does not necessarily derive an empty type.\\

The reason the procedure types behave differently than other type classes is that
they are represented with type variables rather than pure types.
This allows for a nice flat representation and type variable sharing,
however introduces some complexity as described above.

\subsection{Substitution}

When an equals constraint that boils down to setting equality between two different
type variables, we compute the intersection of the types, set the mapping from the
left type variable to the new type in our mapping.
Rather than doing the same for the second type variable, we substitute the left type
variable for the right.
The substitutions have to be done everywhere, that is both in mapping and in all constraints.
The advantage of doing this is that it essentially removes the current constraint
or makes it trivial, and all constraint referencing one of the type variables will
now affect both.
Making these substitutions thus speeds up convergence, as the number of constraints
is effectively reduced by doing so.\\

Note that substitution can only be done in the case the procedure types
of the two types being mapped from the type variables are not both procedure specifications
with different type variables for the same reason as above.

\section{Development process}

%work division, description of the general process

\section{Discussion and future work}

%TODO Ben - branching, reporting, UI

%limitations of our approach, what can be done about it
%directions in which this can be improved, e.g. emacs integration

\end{document}
